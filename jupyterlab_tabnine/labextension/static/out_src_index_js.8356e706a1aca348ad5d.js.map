{"version":3,"file":"out_src_index_js.8356e706a1aca348ad5d.js","mappings":";;;;;;;;;;;;;;AAAsC;AACvB;AACf,WAAW,oDAAU;AACrB;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;ACL+C;AACS;AACxD,iBAAiB,+EAA6B;AAC9C,mBAAmB,8DAAW;AACf;AACf;AACA;AACA,yBAAyB,8EAA4B,eAAe,uCAAuC,SAAS,GAAG;AACvH;AACA;AACA,kBAAkB,+EAA6B;AAC/C;AACA;AACA;AACA,kBAAkB,gFAA8B;AAChD;AACA;AACA;;;;;;;;;;;;;;;;;ACjBoD;AAC7C,kCAAkC,8DAAa;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,6CAA6C,4BAA4B,uBAAuB;AAChG;AACA;AACA,CAAC,0BAA0B;;;;;;;;;;;;;;;;;;AC9ByB;AACK;AAClD,8BAA8B,8DAAa;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,kEAAkE;AAChF;AACA,QAAQ,iEAAgB,GAAG,6HAA6H;AACxJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA,CAAC,0BAA0B;;;;;;;;;;;;;;;;;;;;;AChDoE;AACvC;AACN;AACE;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qEAAkB,EAAE,kEAAgB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,kCAAkC,2DAAmB;AACrD;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,kEAAe;AAClD,oCAAoC,mEAAgB;AACpD,mCAAmC,6DAAe;AAClD,wCAAwC,2DAAmB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,cAAc;AACnF;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,qEAAqE,IAAI;AACzE;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA,iEAAe,SAAS,EAAC","sources":["webpack://@tabnine/jupyterlab/./out/src/binary/postAutocomplete.js","webpack://@tabnine/jupyterlab/./out/src/binary/postBinary.js","webpack://@tabnine/jupyterlab/./out/src/connector.js","webpack://@tabnine/jupyterlab/./out/src/customconnector.js","webpack://@tabnine/jupyterlab/./out/src/index.js"],"sourcesContent":["import postBinary from \"./postBinary\";\nexport default async function postAutocomplete(params) {\n    return postBinary({\n        Autocomplete: params,\n    });\n}\n","import { URLExt } from \"@jupyterlab/coreutils\";\nimport { ServerConnection } from \"@jupyterlab/services\";\nconst settings = ServerConnection.makeSettings();\nconst requestUrl = URLExt.join(settings.baseUrl, \"tabnine\", \"request\");\nexport default async function postBinary(request) {\n    let response;\n    try {\n        response = await ServerConnection.makeRequest(requestUrl, { method: \"POST\", body: JSON.stringify({ request }) }, settings);\n    }\n    catch (error) {\n        throw new ServerConnection.NetworkError(error);\n    }\n    const data = await response.json();\n    if (!response.ok) {\n        throw new ServerConnection.ResponseError(response, data.message);\n    }\n    return data;\n}\n","import { DataConnector } from \"@jupyterlab/statedb\";\nexport class CompletionConnector extends DataConnector {\n    constructor(connectors) {\n        super();\n        this._connectors = connectors;\n    }\n    fetch(request) {\n        return Promise.all(this._connectors.map((connector) => connector.fetch(request))).then((replies) => {\n            const definedReplies = replies.filter((reply) => !!reply);\n            return Private.mergeReplies(definedReplies);\n        });\n    }\n}\nvar Private;\n(function (Private) {\n    function mergeReplies(replies) {\n        const repliesWithMatches = replies.filter((rep) => rep.matches.length > 0);\n        if (repliesWithMatches.length === 0) {\n            return replies[0];\n        }\n        if (repliesWithMatches.length === 1) {\n            return repliesWithMatches[0];\n        }\n        const matches = new Set();\n        repliesWithMatches.forEach((reply) => {\n            reply.matches.forEach((match) => matches.add(match));\n        });\n        return Object.assign(Object.assign({}, repliesWithMatches[0]), { matches: [...matches] });\n    }\n    Private.mergeReplies = mergeReplies;\n})(Private || (Private = {}));\n","import { DataConnector } from \"@jupyterlab/statedb\";\nimport postAutocomplete from './binary/postAutocomplete';\nexport class CustomConnector extends DataConnector {\n    constructor(options) {\n        super();\n        this._editor = options.editor;\n    }\n    fetch(request) {\n        if (!this._editor) {\n            return Promise.reject(\"No editor\");\n        }\n        return new Promise((resolve) => {\n            resolve(Private.completionHint(this._editor));\n        });\n    }\n}\n// i\n/**\n * A namespace for Private functionality.\n */\nvar Private;\n(function (Private) {\n    /**\n     * Get a list of mocked completion hints.\n     *\n     * @param editor Editor\n     * @returns Completion reply\n     */\n    function completionHint(editor) {\n        // Find the token at the cursor\n        const cursor = editor.getCursorPosition();\n        const token = editor.getTokenForPosition(cursor);\n        const tokenList = [\n            { value: token.value + \"Dima\", offset: token.offset, type: \"magic\" },\n        ];\n        postAutocomplete({ before: \"A\", \"after\": \"B\", max_num_results: 5, filename: \"bilu\", region_includes_end: true, region_includes_beginning: true });\n        // Only choose the ones that have a non-empty type field, which are likely to be of interest.\n        const completionList = tokenList.filter((t) => t.type).map((t) => t.value);\n        // Remove duplicate completions from the list\n        const matches = Array.from(new Set(completionList));\n        return {\n            start: token.offset,\n            end: token.offset + token.value.length,\n            matches,\n            metadata: {},\n        };\n    }\n    Private.completionHint = completionHint;\n})(Private || (Private = {}));\n","import { ContextConnector, ICompletionManager, KernelConnector, } from \"@jupyterlab/completer\";\nimport { INotebookTracker } from \"@jupyterlab/notebook\";\nimport { CompletionConnector } from \"./connector\";\nimport { CustomConnector } from \"./customconnector\";\n/**\n * The command IDs used by the console plugin.\n */\nvar CommandIDs;\n(function (CommandIDs) {\n    CommandIDs.invoke = \"completer:invoke\";\n    CommandIDs.invokeNotebook = \"completer:invoke-notebook\";\n    CommandIDs.select = \"completer:select\";\n    CommandIDs.selectNotebook = \"completer:select-notebook\";\n})(CommandIDs || (CommandIDs = {}));\n/**\n *\n * Initialization data for the extension.\n */\nconst extension = {\n    id: \"completer\",\n    autoStart: true,\n    requires: [ICompletionManager, INotebookTracker],\n    activate: async (app, completionManager, notebooks) => {\n        console.log(\"JupyterLab custom completer extension is activated!\");\n        // Modelled after completer-extension's notebooks plugin\n        notebooks.widgetAdded.connect((sender, panel) => {\n            var _a, _b;\n            let editor = (_b = (_a = panel.content.activeCell) === null || _a === void 0 ? void 0 : _a.editor) !== null && _b !== void 0 ? _b : null;\n            const session = panel.sessionContext.session;\n            const options = { session, editor };\n            const connector = new CompletionConnector([]);\n            const handler = completionManager.register({\n                connector,\n                editor,\n                parent: panel,\n            });\n            const updateConnector = () => {\n                var _a, _b;\n                editor = (_b = (_a = panel.content.activeCell) === null || _a === void 0 ? void 0 : _a.editor) !== null && _b !== void 0 ? _b : null;\n                options.session = panel.sessionContext.session;\n                options.editor = editor;\n                handler.editor = editor;\n                const kernel = new KernelConnector(options);\n                const context = new ContextConnector(options);\n                const custom = new CustomConnector(options);\n                handler.connector = new CompletionConnector([\n                    kernel,\n                    context,\n                    custom,\n                ]);\n            };\n            // Update the handler whenever the prompt or session changes\n            panel.content.activeCellChanged.connect(updateConnector);\n            panel.sessionContext.sessionChanged.connect(updateConnector);\n        });\n        // Add notebook completer command.\n        app.commands.addCommand(CommandIDs.invokeNotebook, {\n            execute: () => {\n                var _a;\n                const panel = notebooks.currentWidget;\n                if (panel && ((_a = panel.content.activeCell) === null || _a === void 0 ? void 0 : _a.model.type) === \"code\") {\n                    return app.commands.execute(CommandIDs.invoke, { id: panel.id });\n                }\n            },\n        });\n        // Add notebook completer select command.\n        app.commands.addCommand(CommandIDs.selectNotebook, {\n            execute: () => {\n                const id = notebooks.currentWidget && notebooks.currentWidget.id;\n                if (id) {\n                    return app.commands.execute(CommandIDs.select, { id });\n                }\n            },\n        });\n        // Set enter key for notebook completer select command.\n        app.commands.addKeyBinding({\n            command: CommandIDs.selectNotebook,\n            keys: [\"Enter\"],\n            selector: \".jp-Notebook .jp-mod-completer-active\",\n        });\n    },\n};\nexport default extension;\n"],"names":[],"sourceRoot":""}